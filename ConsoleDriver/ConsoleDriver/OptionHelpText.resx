<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AllowDuplicateSections" xml:space="preserve">
    <value>Allows duplicate sections. Additional sections parsed replace the original section in the map, but are preserved when output to text.</value>
  </data>
  <data name="AllowGlobalKeys" xml:space="preserve">
    <value>Allows keys to occur outside of a section. They can be accessed through the section named `&lt;global&gt;`.</value>
  </data>
  <data name="AlwaysUseQuotation" xml:space="preserve">
    <value>Like UseQuotation, but always writes quotation marks to text, whether the value has leading or trailing whitespace or not.</value>
  </data>
  <data name="BothSides" xml:space="preserve">
    <value>A single space is added on either side of the delimiter.</value>
  </data>
  <data name="ColonDelimiter" xml:space="preserve">
    <value>Accepts a `:` token to assign a value to a key.</value>
  </data>
  <data name="CrLfNewline" xml:space="preserve">
    <value>Writes `\r\n` to text.</value>
  </data>
  <data name="DefaultEnvironmentNewline" xml:space="preserve">
    <value>Writes `System.Environment.NewLine` to text.</value>
  </data>
  <data name="DisallowDuplicateKeys" xml:space="preserve">
    <value>Disallows duplicate keys and throws an exception when the parser encounters one. Adding a value to a key replaces the old value.</value>
  </data>
  <data name="DisallowDuplicateSections" xml:space="preserve">
    <value>Disallows duplicate sections and throws an exception when the parser encounters one.</value>
  </data>
  <data name="DisallowGlobalKeys" xml:space="preserve">
    <value>Disallows global keys and throws an exception when a key is encountered outside of a section.</value>
  </data>
  <data name="DuplicateKeyAddsValue" xml:space="preserve">
    <value>Allows duplicate keys. Additional keys parsed and values added to the configuration accumulate new values. All keys parsed and added are preserved when output to text.</value>
  </data>
  <data name="DuplicateKeyReplacesValue" xml:space="preserve">
    <value>Allows duplicate keys. Additional keys parsed with the same name replace the old value of the key, but are preserved when output to text.</value>
  </data>
  <data name="EqualsDelimiter" xml:space="preserve">
    <value>Accepts a `=` token to assign a value to a key.</value>
  </data>
  <data name="EqualsOrColonDelimiter" xml:space="preserve">
    <value>Accepts a `=` or `:` token to assign a value to a key.</value>
  </data>
  <data name="HashAndSemicolonComments" xml:space="preserve">
    <value>Comments may begin with either a `#` or a `;` token</value>
  </data>
  <data name="HashComments" xml:space="preserve">
    <value>Comments may begin with a `#` token</value>
  </data>
  <data name="IgnoreEscapeSequences" xml:space="preserve">
    <value>Escape sequences are ignored and parsed as literal text.</value>
  </data>
  <data name="IgnoreQuotation" xml:space="preserve">
    <value>Quotation marks are parsed as literal text and are included in the key value.</value>
  </data>
  <data name="LeftOnly" xml:space="preserve">
    <value>A single space is added on the left side of the delimiter only.</value>
  </data>
  <data name="LfNewLine" xml:space="preserve">
    <value>Writes `\n` to text.</value>
  </data>
  <data name="MergeDuplicateSectionIntoOriginal" xml:space="preserve">
    <value>Allows duplicate sections. When a duplicate section is encountered, its keys are appended to the original section. The duplicate is not preserved when output to text.</value>
  </data>
  <data name="MergeOriginalSectionIntoDuplicate" xml:space="preserve">
    <value>Allows duplicate sections. When a duplicate section is encountered, the original section is removed from its original position and its keys are appended to the duplicate section. The original section is not preserved when output to text.</value>
  </data>
  <data name="NoDelimiter" xml:space="preserve">
    <value>Keys and values are separated only by whitespace.</value>
  </data>
  <data name="NoSpacing" xml:space="preserve">
    <value>No space is inserted on either side of the delimiter.</value>
  </data>
  <data name="PreferColonDelimiter" xml:space="preserve">
    <value>Writes the colon delimiter to text.</value>
  </data>
  <data name="PreferEqualsDelimiter" xml:space="preserve">
    <value>Writes the equal delimiter to text.</value>
  </data>
  <data name="PreferNoDelimiter" xml:space="preserve">
    <value>Writes no delimiter except a single space between keys and values.</value>
  </data>
  <data name="RightOnly" xml:space="preserve">
    <value>A single space is added on the right side of the delimiter only.</value>
  </data>
  <data name="SemicolonComments" xml:space="preserve">
    <value>Comments may begin with a `;` token</value>
  </data>
  <data name="UseEscapeSequences" xml:space="preserve">
    <value>Accepts the escape sequences `\0`, `\a`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`, `\\"`, `\'`, `\#`, `\:`, `\ ` and `\xHHHH`</value>
  </data>
  <data name="UseEscapeSequencesAndLineContinuation" xml:space="preserve">
    <value>Accepts the escape sequences `\0`, `\a`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`, `\\"`, `\'`, `\#`, `\:`, `\ ` and `\xHHHH`, as well as the line continuation token `\`</value>
  </data>
  <data name="UseQuotation" xml:space="preserve">
    <value>Quotation marks are treated as their own type of token and are not included in the key value. Any leading or trailing whitespace is included in the key value. Additionally, quotation marks are automatically added when adding leading or trailing whitespace to a key value.</value>
  </data>
</root>